{"text":"[{\"pos\":35161,\"text\":\"I am Paul, I work on the web developer relations team. \"},{\"pos\":43341,\"text\":\"I typically talk about performance. \"},{\"pos\":60601,\"text\":\"Today I want to talk about building stuff. \"},{\"pos\":74601,\"text\":\"I will tell you the overall story about how this fits. \"},{\"pos\":83861,\"text\":\"/n//n/We have mentioned a bunch of things about progressive web apps. \"},{\"pos\":94741,\"text\":\"You need https for a bunch of features. \"},{\"pos\":106241,\"text\":\"Like push messaging. \"},{\"pos\":117741,\"text\":\"Service workers, which help you with the offline story, require https. \"},{\"pos\":131121,\"text\":\"/n//n/I love the stuff about poor connectivity. \"},{\"pos\":158621,\"text\":\"Service workers help with poor connectivity. \"},{\"pos\":177881,\"text\":\"/n//n/Closer look at the home screen reveals an interesting challenge for us. \"},{\"pos\":186841,\"text\":\"Which of these are progressive web apps, which are the native apps?\"},{\"pos\":197640,\"text\":\"/n/User is thinking: \\\"that app looks like native, I hope it behaves like that\\\"\"},{\"pos\":225361,\"text\":\"<span class=\\\"t\\\">Performance</span>\"},{\"pos\":234861,\"text\":\"We have talked in terms of a model called RAIL - Response, Animation, Idle, Load. \"},{\"pos\":244101,\"text\":\"/n/Response = 0.1 seconds\"},{\"pos\":256341,\"text\":\"/n/Animation = 16 milliseconds\"},{\"pos\":264841,\"text\":\"/n/Idle = 50 milliseconds\"},{\"pos\":281101,\"text\":\"/n/Load = 1 second\"},{\"pos\":297581,\"text\":\"/n/Often people think we are saying all of it is top priority and must do. \"},{\"pos\":305861,\"text\":\"Reality tells us something else. \"},{\"pos\":339121,\"text\":\"If we are on a home screen, the priority changes a bit. \"},{\"pos\":356861,\"text\":\"/n/Assume app has been added to the homescreen. \"},{\"pos\":362941,\"text\":\"User was probably prompted. \"},{\"pos\":370681,\"text\":\"It is probably because you satisfied some criteria - e.g. you have a service worker. \"},{\"pos\":390581,\"text\":\"So for home screen, the importance graph changes. \"},{\"pos\":445081,\"text\":\"<span class=\\\"t\\\">Three components</span>\"},{\"pos\":468321,\"text\":\"1. SideNav\"},{\"pos\":471801,\"text\":\"/n/2. Dismissable card system\"},{\"pos\":471802,\"text\":\"/n/3. Expanding and collapsing view\"},{\"pos\":476701,\"text\":\"<span class=\\\"t\\\">Side Navigation</span>\"},{\"pos\":492501,\"text\":\"Let us consider some theory. \"},{\"pos\":502501,\"text\":\"We have a containing element. \"},{\"pos\":507241,\"text\":\"We place a black background.\"},{\"pos\":517741,\"text\":\"We have a side nav content, which we slide in and out. \"},{\"pos\":527901,\"text\":\"I make position: fixed. \"},{\"pos\":541641,\"text\":\"I make overflow: hidden. \"},{\"pos\":550901,\"text\":\"I also have pointer-events: none. \"},{\"pos\":559141,\"text\":\"We want the sidenav ready to come and go, we don't want it out of the render tree. \"},{\"pos\":581241,\"text\":\"So clicks will pass through to underlying content. \"},{\"pos\":585741,\"text\":\"When we bring the side nav up, we switch it to pointer-events: auto. \"},{\"pos\":594381,\"text\":\"So consider pointer-event set to none for such elements. \"},{\"pos\":599101,\"text\":\"/n/Promote it to its own layer. \"},{\"pos\":628581,\"text\":\"Easiest way is to use will-change: transform. \"},{\"pos\":657721,\"text\":\"When the layer is separated from the page, we can use transform and move it around. \"},{\"pos\":662801,\"text\":\"We don't have to repaint the page content behind it. \"},{\"pos\":674661,\"text\":\"/n//n/Should I promote every element? \"},{\"pos\":682921,\"text\":\"Don't do it. \"},{\"pos\":688661,\"text\":\"/n/1. Keep your memory usage down\"},{\"pos\":701421,\"text\":\"/n/2. Keep time spent in compositing to a minimum\"},{\"pos\":720321,\"text\":\"/n//n/So we will translate the side-nav out of the view. \"},{\"pos\":759821,\"text\":\"Add class to side-nav to remove the transform. \"},{\"pos\":785321,\"text\":\"/n/We also use opacity.\"},{\"pos\":789321,\"text\":\"Dismissing the side-nav: similar but in reverse. \"},{\"pos\":828821,\"text\":\"Add a cancel to stop propagation of event. \"},{\"pos\":834481,\"text\":\"/n/Behavior expectation: gesture to get rid of side-nav. \"},{\"pos\":877721,\"text\":\"Visually update every frame with requestAnimationFrame. \"},{\"pos\":915481,\"text\":\"/n/The onTouchMove method. \"},{\"pos\":926221,\"text\":\"We want to use preventDefault. \"},{\"pos\":945981,\"text\":\"/n/update method. \"},{\"pos\":947961,\"text\":\"Make sure we don't go past 0, and apply a translation to the container. \"},{\"pos\":958441,\"text\":\"/n/onTouchEnd: remove transform. \"},{\"pos\":999301,\"text\":\"/n/Looking at the dev tools timeline: The fps is a steady 60fps. We are doing really well on fps. \"},{\"pos\":1043801,\"text\":\"<span class=\\\"t\\\">Swipeable cards</span>\"},{\"pos\":1052061,\"text\":\"They are not primed, we don't know which card will be used. \"},{\"pos\":1065741,\"text\":\"Theory: promote to layer, but at the last minute. \"},{\"pos\":1083481,\"text\":\"Transform + opacity are our two best friends when it comes to animating performantly. \"},{\"pos\":1097321,\"text\":\"/n/Decoupling touch input from the visual update - pretty much what game developers do as well. \"},{\"pos\":1117281,\"text\":\"Imagine every frame, we call requestAnimationFrame for every frame and if we get a touchmove event we will incorporate that into the frame. \"},{\"pos\":1175321,\"text\":\"/n/An aside about bind: copying from the prototype into the instance. \"},{\"pos\":1194481,\"text\":\"And binding it in the process. \"},{\"pos\":1199741,\"text\":\"The key benefits: this refers to instance, and not event target. \"},{\"pos\":1210601,\"text\":\"Also they are named - I can remove event listeners more easily. \"},{\"pos\":1226701,\"text\":\"/n/onStart: we will use javascript to manually promote the card we are interacting with. \"},{\"pos\":1262601,\"text\":\"/n/onMove: pretty straightforward. \"},{\"pos\":1277361,\"text\":\"/n/update: if you are dragging the card, the translateX is currentX - startX. \"},{\"pos\":1285661,\"text\":\"We use a transform to just move it. \"},{\"pos\":1315521,\"text\":\"/n/I put thresholds to decide when to dismiss cards. \"},{\"pos\":1358801,\"text\":\"/n//n//i/Formula for value./\"},{\"pos\":1397041,\"text\":\"/n/It basically slows down as we get closer and closer to the target. \"},{\"pos\":1419881,\"text\":\"<span class=\\\"t\\\">Detecting done-ness</span>\"},{\"pos\":1436621,\"text\":\"Ask if translation is small enough. \"},{\"pos\":1461381,\"text\":\"Check if it is invisible. \"},{\"pos\":1474381,\"text\":\"Slide all the other cards into place. \"},{\"pos\":1543881,\"text\":\"/n/Dev-tools: very green. \"},{\"pos\":1568621,\"text\":\"There is a little dip in fps at the start of the slide cards. \"},{\"pos\":1601521,\"text\":\"<span class=\\\"t\\\">Expand and Collapse</span>\"},{\"pos\":1607781,\"text\":\"It is the most challenging - we don't know where we are starting and where we are finishing. \"},{\"pos\":1659241,\"text\":\"The size is changing. \"},{\"pos\":1671761,\"text\":\"Look up csstriggers.com. \"},{\"pos\":1706261,\"text\":\"You will trigger layout and trigger paint. \"},{\"pos\":1717001,\"text\":\"Not a good idea for every story of animation. \"},{\"pos\":1733261,\"text\":\"Again, transforms are useful here. \"},{\"pos\":1744261,\"text\":\"So can we do that effect with transforms? \"},{\"pos\":1758501,\"text\":\"We can use the scaled transforms. \"},{\"pos\":1768761,\"text\":\"The approach I take is FLIP it. \"},{\"pos\":1773741,\"text\":\"/n/First - where the thing starts on screen. \"},{\"pos\":1788741,\"text\":\"We can use getBoundingClientRect. \"},{\"pos\":1813461,\"text\":\"We can then immediately snap animation. \"},{\"pos\":1830461,\"text\":\"/n/Last - call getBoundingClientRect again. \"},{\"pos\":1848221,\"text\":\"We know where we started, and where we finished. \"},{\"pos\":1861761,\"text\":\"/n/Layout is not as bad here: 1. We only do it once. 2. RAIL to the rescue!\"},{\"pos\":1905261,\"text\":\"<span class=\\\"t\\\">RAIL + FLIP</span>\"},{\"pos\":1917761,\"text\":\"You can typically afford to do a styles + layout pass. You should do it once. It needs to complete in &lt; 100ms. \"},{\"pos\":1929101,\"text\":\"/n/We can now introduce the transform to this. \"},{\"pos\":2003101,\"text\":\"<span class=\\\"t\\\">FLIP caveats</span>\"},{\"pos\":2010841,\"text\":\"Scales change child elements; you may need to use siblings\"},{\"pos\":2039481,\"text\":\"/n/First to Last involves forcing styles &amp; layout; be careful. \"},{\"pos\":2068621,\"text\":\"<span class=\\\"t\\\">FLIP is responsive web design friendly</span>\"},{\"pos\":2090621,\"text\":\"Dev-tools inspection. \"},{\"pos\":2162301,\"text\":\"<span class=\\\"t\\\">Closing thoughts</span>\"},{\"pos\":2167561,\"text\":\"Promote elements that you intend to animate; use sparingly\"},{\"pos\":2183021,\"text\":\"/n/Stick to transform and opacity changes wherever possible\"},{\"pos\":2200781,\"text\":\"/n/Use FLIP to remap expensive properties to transforms\"},{\"pos\":2238021,\"text\":\"/n//n/We have a section on google web fundamentals if you are new to this stuff. \"},{\"pos\":2263001,\"text\":\"/n//n/Link to source code: http://bit.ly/supercharged-ui\"}]","css":".t{font-weight:bold;}.t:before{content:\"\\A\\A\";white-space: pre;}.t:after{content:\"\\A\";white-space: pre;}","videoid":"thNyy5eYfbc","title":"High performance web user interfaces  - Google I/O 2016","duration":2364.721}